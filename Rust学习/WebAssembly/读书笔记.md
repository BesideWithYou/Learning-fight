要写WebAssembly 首先不能选用有GC的语言，不然垃圾收集器的代码也会占用很大一部分的体积，对 WASM 的加载并不友好。所以比较好的选择就是C/C++/Rust，而 Rust 对于前端选手来说会稍微亲切一些，语法和 TS 有一丢丢的相似，也会更容易上手一点。

# 第一部分

## 第一章 LLVM

所有的 WebAssembly 编译器底层都使用了LLVM去将原生代码（如Rust、C、C++等）转换成 WebAssembly 二进制代码。

### 编译器：

编译器包括三部分:

前端：负责处理源语言

优化器：负责优化代码

后端：负责处理目标语言

### 前端：

前端在接收到代码的时候就会去解析它，然后检查代码是否有语法或语法问题，然后代码就会转换成中间产物（intermediate representation) IR。

### 优化器:

优化器会去分析 IR 并将其转换成更加高效的代码，很少有编译器会有多个中间产物。优化器相当于一个中间产物到中间产物的转换器，其实就是在中间做了一层加工优化处理，优化器包括移除冗余的计算，去掉执行不到的死代码，还有一些其它的可以进行优化的选项。

### 后端：

后端会接收中间产物并转换它到其它语言（如机器码），它也可以链接多个后端去转换代码到一些其它语言。为了产生高效的机器代码，后端应该理解执行代码的体系结构。

### 理解LLVM

LLVM是一个编译器，用于处理LLVM IR。LLVM的核心是负责提供独立于源、目标的优化，并为许多CPU架构生成代码。这使得语言开发人员可以只创建一个前端，从源语言生成LLVM兼容的IR或LLVM IR。

- LLVM使用一种简单的低级语言，看起来类似C语言

- LLVM是强类型的

- LLVM有严格定义的语义

- LLVM具有精确的垃圾回收

- LLVM提供了各种优化，可以根据需求选择。它具有积极的、标量的、过程间的、简单循环的和概要文件驱动的优化
- LLVM提供了各种编译模型。分别是链接时间、安装时间、运行时和脱机
- LLVM为各种目标架构生成机器码
- LLVM提供DWARF调试信息（DWARF是一种调试文件格式，许多编译器和调试器都使用它来支持源代码级别的调试）

LLVM不是一个单一项目。它是子项目和其他项目的集合。这些项目被各种语言使用，比如Ruby，

Python, Haskell, Rust和D编译。

## 第二章 Emscripten

将C/C++编译成WebAssembly的，掠过

## 第三章 探索 WebAssembly 模块

> WebAssembly 的主要目标就是要去构建高效的应用。

它是一个低级别的类汇编语言，设计用于高效执行和紧凑表达，它可以以接近原生代码的速度在所有JS引擎上执行(手机、电脑浏览器、Node.js)。

每个 WebAssembly 文件都是一个高效、最优且自给自足的模块，称为 WebAssembly 模块(WASM)，它运行在沙盒上，内存安全，没有权限获取超出沙盒限制以外的东西。WebAssembly 是一个虚拟指令集结构。

JavaScript 代码的执行过程是：

- 把整个文件加载完成
- 将代码解析成抽象语法树
- 解释器进行解释然后编译再执行
- 最后再进行垃圾回收。

JavaScript既是解释语言又是编译语言，所以 JavaScript 引擎在解析后启动执行。解释器执行代码的速度很快，但它每次解释时都会编译代码，这个阶段称为解释。

JavaScript引擎有监视器(在某些浏览器中称为分析器)。监视器跟踪代码执行情况。如果一个特定的代码块被频繁地执行，那么监视器将其标记为热代码。引擎使用即时(JIT)编译器编译代码块。引擎会花费一些时间进行编译，比如以纳秒为单位。花在这里的时间是值得的，因为下次调用函数时，执行速度会快得多，因为编译版本总是比解释版本快。这个阶段称为优化。

JavaScript引擎增加了一(或两)层优化。监视器继续监视代码执行。监视器标记那些被执行频次更高的代码为非常热门(very hot)的代码，引擎将进一步优化这段代码。这个优化需要很长时间。这个阶段产生运行速度非常快的高度优化过的代码。此代码比之前优化的代码和解释版本要快得多。显然，引擎在这一阶段花费了更多时间，比如以毫秒为单位，这里耗费的时间将由代码性能和执行频率补偿。

JavaScript是一种动态类型的语言，引擎所能做的所有优化都是基于类型的推断。如果推断失败，那么将重新解释并执行代码，并删除优化过的代码，而不是抛出运行时异常。JavaScript引擎实现必要的类型检查，并在推断的类型发生变化时提取优化的代码。但是花在上述代码优化阶段的功夫就白费了。

可以通过使用 TypeScript 来防止这些与类型相关的问题。TypeScript 是 JavaScript 的超集。使用 TypeScript，可以防止多态代码 (接受不同类型的代码)。在JavaScript引擎中，只接受一种类型的代码总是比多态代码运行得快。

最后一步是垃圾回收，将删除内存中的所有活动对象。JavaScript 引擎中的垃圾回收采用标记清除算法。在垃圾回收过程中，JavaScript引擎从根对象 (类似于Node.js中的全局对象) 开始。它查找从根对象引用的所有对象，并将它们标记为可访问对象。它将剩余的对象标记为不可访问的对象。最后清除不可访问的对象。

### 在 JS 引擎中 WebAssembly 是怎么执行的？

WASM 是二进制格式并且已经被编译和优化过了，首先JS 引擎会去加载 WASM 代码，然后解码并转换成模块的内部表达（即AST)。这个阶段是解码阶段，解码阶段要远远比 JS 的编译阶段要快。

获取WASM二进制代码 -> 解码 -> 编译 -> 执行。

接下来，解码后的WASM进入编译阶段。在这个阶段，对模块进行验证，在验证期间，对代码进行某些条件检查，以确保模块是安全的，没有任何有害的代码。在验证过程中对函数、指令序列和堆栈的使用进行类型检查，然后将验证过的代码编译为机器码。由于 WASM 已经编译和优化过了，所以编译阶段会更快，在这个阶段，WASM 被转换为机器码。

最后编译过的代码进入执行阶段，执行阶段，模块会被实例化并执行。在实例化的时候，JS 引擎会实例化状态和执行栈，最后再执行模块。

WASM 的另一个优点是模块可以从第一个字节开始编译和实例化。因此，JavaScript引擎不需要等到整个模块被下载。这进一步提高了WebAssembly的性能。

WASM 快的原因是因为它的执行步骤要比JS 的执行步骤少，其二进制代码已经经过了优化和编译，并且可以进行流式编译。

但是总的来说，WASM 并不是总是比原生JS 代码执行速度要快的，因为 WASM 代码和 JS 引擎交互和实例化也是要耗费时间的，所以需要考虑好使用场景。

# 第二部分

##  WebAssembly 二进制工具包

官方地址：[GitHub - WebAssembly/wabt: The WebAssembly Binary Toolkit](https://github.com/WebAssembly/wabt)

Rust 编译器将 Rust 代码转换为WebAssembly 二进制代码。但是生成的二进制文件都是经过了相关的压缩和性能优化的。它很难理解、调试和验证(它是一堆十六进制数)。转换 WebAssembly 二进制到原始源代码很难。WebAssembly 二进制工具包 (WABT) 帮助将 WebAssembly 二进制转换为人类可读的格式，例如WebAssembly 文本 (WAST) 格式或 C 语言原生代码。WABT 工具包在 WebAssembly 的开发生态中很重要，是我们开发 WebAssembly 中的重要一环。

WABT（WebAssembly Binary ToolKit) 有以下的能力：

- wat2wasm：转换 WAST 到 WASM
- wasm2wat：转换 WASM 到 WAST
- wasm2c：转换 WASM 到 C 语言
- wast2json：转换 WAST 到 JSON
- wasm-validate：验证 WASM 是否按照规范来构建
- wasm-decomplie：反编译 WASM 代码到类似于 C 语言的语法的可读代码

##  WebAseembly 模块

# 第三部分

## Rust

Rust 提供了对 WebAssembly 一流的支持，Rust 不需要运行时让它成为了 WebAssembly 的完美候选者。

