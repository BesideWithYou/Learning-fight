## 第一章 LLVM

所有的 WebAssembly 编译器底层都使用了LLVM去将原生代码（如Rust、C、C++等）转换成 WebAssembly 二进制代码。

### 编译器：

编译器包括三部分:

前端：负责处理源语言

优化器：负责优化代码

后端：负责处理目标语言

### 前端：

前端在接收到代码的时候就会去解析它，然后检查代码是否有语法或语法问题，然后代码就会转换成中间产物（intermediate representation) IR。

### 优化器:

优化器会去分析 IR 并将其转换成更加高效的代码，很少有编译器会有多个中间产物。优化器相当于一个中间产物到中间产物的转换器，其实就是在中间做了一层加工优化处理，优化器包括移除冗余的计算，去掉执行不到的死代码，还有一些其它的可以进行优化的选项。

### 后端：

后端会接收中间产物并转换它到其它语言（如机器码），它也可以链接多个后端去转换代码到一些其它语言。为了产生高效的机器代码，后端应该理解执行代码的体系结构。

### 理解LLVM

LLVM是一个编译器，用于处理LLVM IR。LLVM的核心是负责提供独立于源、目标的优化，并为许多CPU架构生成代码。这使得语言开发人员可以只创建一个前端，从源语言生成LLVM兼容的IR或LLVM IR。

- LLVM使用一种简单的低级语言，看起来类似C语言

- LLVM是强类型的

- LLVM有严格定义的语义

- LLVM具有精确的垃圾回收

- LLVM提供了各种优化，可以根据需求选择。它具有积极的、标量的、过程间的、简单循环的和概要文件驱动的优化
- LLVM提供了各种编译模型。分别是链接时间、安装时间、运行时和脱机
- LLVM为各种目标架构生成机器码
- LLVM提供DWARF调试信息（DWARF是一种调试文件格式，许多编译器和调试器都使用它来支持源代码级别的调试）

LLVM不是一个单一项目。它是子项目和其他项目的集合。这些项目被各种语言使用，比如Ruby，

Python, Haskell, Rust和D编译。

## 第二章 Emscripten

