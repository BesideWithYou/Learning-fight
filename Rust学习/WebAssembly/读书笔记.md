要写 WebAssembly 首先不能选用有 GC 的语言，不然垃圾收集器的代码也会占用很大一部分的体积，对 WASM 的加载并不友好。所以比较好的选择就是C/C++/Rust，而 Rust 对于前端选手来说会稍微亲切一些，语法和 TS 有一丢丢的相似，也会更容易上手一点，并且 Rust 对于 WASM 有一流的支持，用来写 WASM 再好不过了。

## LLVM

所有的 WASM 编译器底层都使用了LLVM 去将原生代码（如Rust、C、C++等）转换成 WASM 二进制代码。

### 编译器：

编译器包括三部分:

前端：负责处理源语言

优化器：负责优化代码

后端：负责处理目标语言

### 前端：

前端在接收到代码的时候就会去解析它，然后检查代码是否有语法或语法问题，然后代码就会转换成中间产物（intermediate representation) IR。

### 优化器:

优化器会去分析 IR 并将其转换成更加高效的代码，很少有编译器会有多个中间产物。优化器相当于一个中间产物到中间产物的转换器，其实就是在中间做了一层加工优化处理，优化器包括移除冗余的计算，去掉执行不到的死代码，还有一些其它的可以进行优化的选项。

### 后端：

后端会接收中间产物并转换它到其它语言（如机器码），它也可以链接多个后端去转换代码到一些其它语言。为了产生高效的机器代码，后端应该理解执行代码的体系结构。

### 理解LLVM

LLVM是一个编译器，用于处理LLVM IR。LLVM的核心是负责提供独立于源、目标的优化，并为许多CPU架构生成代码。这使得语言开发人员可以只创建一个前端，从源语言生成LLVM兼容的IR或LLVM IR。

- LLVM使用一种简单的低级语言，看起来类似C语言

- LLVM是强类型的

- LLVM有严格定义的语义

- LLVM具有精确的垃圾回收

- LLVM提供了各种优化，可以根据需求选择。它具有积极的、标量的、过程间的、简单循环的和概要文件驱动的优化
- LLVM提供了各种编译模型。分别是链接时间、安装时间、运行时和脱机
- LLVM为各种目标架构生成机器码
- LLVM提供DWARF调试信息（DWARF是一种调试文件格式，许多编译器和调试器都使用它来支持源代码级别的调试）

LLVM不是一个单一项目。它是子项目和其他项目的集合。这些项目被各种语言使用，比如Ruby，Python, Haskell, Rust和D编译。

## 探索 WebAssembly 模块

> WASM 的主要目标就是要去构建高效的应用。

它是一个低级别的类汇编语言，设计用于高效执行和紧凑表达，它可以以接近原生代码的速度在所有JS引擎上执行(手机、电脑浏览器、Node.js)。

每个 WebAssembly 文件都是一个高效、最优且自给自足的模块，称为 WebAssembly 模块(WASM)，它运行在沙盒上，内存安全，没有权限获取超出沙盒限制以外的东西。WebAssembly 是一个虚拟指令集结构。

JavaScript 代码的执行过程是：

- 把整个文件加载完成
- 将代码解析成抽象语法树
- 解释器进行解释然后编译再执行
- 最后再进行垃圾回收。

JavaScript既是解释语言又是编译语言，所以 JavaScript 引擎在解析后启动执行。解释器执行代码的速度很快，但它每次解释时都会编译代码，这个阶段称为解释。

JavaScript引擎有监视器(在某些浏览器中称为分析器)。监视器跟踪代码执行情况。如果一个特定的代码块被频繁地执行，那么监视器将其标记为热代码。引擎使用即时(JIT)编译器编译代码块。引擎会花费一些时间进行编译，比如以纳秒为单位。花在这里的时间是值得的，因为下次调用函数时，执行速度会快得多，因为编译版本总是比解释版本快。这个阶段称为优化。

JavaScript引擎增加了一(或两)层优化。监视器继续监视代码执行。监视器标记那些被执行频次更高的代码为非常热门(very hot)的代码，引擎将进一步优化这段代码。这个优化需要很长时间。这个阶段产生运行速度非常快的高度优化过的代码。此代码比之前优化的代码和解释版本要快得多。显然，引擎在这一阶段花费了更多时间，比如以毫秒为单位，这里耗费的时间将由代码性能和执行频率补偿。

JavaScript是一种动态类型的语言，引擎所能做的所有优化都是基于类型的推断。如果推断失败，那么将重新解释并执行代码，并删除优化过的代码，而不是抛出运行时异常。JavaScript引擎实现必要的类型检查，并在推断的类型发生变化时提取优化的代码。但是花在上述代码优化阶段的功夫就白费了。

可以通过使用 TypeScript 来防止这些与类型相关的问题。使用 TypeScript，可以防止多态代码 (接受不同类型的代码)。在JavaScript引擎中，只接受一种类型的代码总是比多态代码运行得快，但是如果是带有泛型的代码，那也会被影响到执行速度。

最后一步是垃圾回收，将删除内存中的所有活动对象。JavaScript 引擎中的垃圾回收采用标记清除算法。在垃圾回收过程中，JavaScript引擎从根对象 (类似于Node.js中的全局对象) 开始。它查找从根对象引用的所有对象，并将它们标记为可访问对象。它将剩余的对象标记为不可访问的对象。最后清除不可访问的对象。

### 在 JS 引擎中 WebAssembly 是怎么执行的？

WASM 是二进制格式并且已经被编译和优化过了，首先JS 引擎会去加载 WASM 代码，然后解码并转换成模块的内部表达（即 AST)。这个阶段是解码阶段，解码阶段要远远比 JS 的编译阶段要快。

获取 WASM 二进制代码 -> 解码 -> 编译 -> 执行。

接下来，解码后的 WASM 进入编译阶段。在这个阶段，对模块进行验证，在验证期间，对代码进行某些条件检查，以确保模块是安全的，没有任何有害的代码。在验证过程中对函数、指令序列和堆栈的使用进行类型检查，然后将验证过的代码编译为机器码。由于 WASM 已经编译和优化过了，所以编译阶段会更快，在这个阶段，WASM 被转换为机器码。

最后编译过的代码进入执行阶段，执行阶段，模块会被实例化并执行。在实例化的时候，JS 引擎会实例化状态和执行栈，最后再执行模块。

WASM 的另一个优点是模块可以从第一个字节开始编译和实例化。因此，JS 引擎不需要等到整个模块被下载。这进一步提高了WASM 的性能。

WASM 快的原因是因为它的执行步骤要比JS 的执行步骤少，其二进制代码已经经过了优化和编译，并且可以进行流式编译。

但是总的来说，WASM 并不是总是比原生JS 代码执行速度要快的，因为 WASM 代码和 JS 引擎交互和实例化也是要耗费时间的，所以需要考虑好使用场景。

##  WebAssembly 二进制工具包

官方地址：[GitHub - WebAssembly/wabt: The WebAssembly Binary Toolkit](https://github.com/WebAssembly/wabt)

Rust 编译器将 Rust 代码转换为WASM 二进制代码。但是生成的二进制文件都是经过了相关的压缩和性能优化的。它很难理解、调试和验证(它是一堆十六进制数)。转换 WASM 二进制到原始源代码很难。WebAssembly 二进制工具包 (WABT) 帮助将 WASM 二进制转换为人类可读的格式，例如 WASM  文本 (WAST) 格式或 C 语言原生代码。WABT 工具包在 WASM 的开发生态中很重要，是我们开发 WASM 中的重要一环。

WABT（WebAssembly Binary ToolKit) 有以下的能力：

- wat2wasm：转换 WAST 到 WASM
- wasm2wat：转换 WASM 到 WAST
- wasm2c：转换 WASM 到 C 语言
- wast2json：转换 WAST 到 JSON
- wasm-validate：验证 WASM 是否按照规范来构建
- wasm-decomplie：反编译 WASM 代码到类似于 C 语言的语法的可读代码

## Rust

Rust 提供了对 WASM 一流的支持，Rust 不需要运行时让它成为了 WASM 的完美候选者。

Rust 是怎么编译成 WASM 代码的：

Rust源码 _parse_ -> AST _resolves_ -> High Level IR _type checked_ -> Middle IR -> LLVM IR -> WASM / Other Target

### 开发

将 Rust 编译成 wasm 的命令

```bash
cargo build --target wasm32-unknown-unknown
```

#### wasm-bindgen 

wasm-bindgen 用于将实体从 Rust 绑定到 JavaScript，或反过来。

wasm-bindgen提供了JavaScript 和  WASM  之间的通道，用来传递数字、对象、字符串、数组这些数据类型

安装：

```bash
cargo install wasm-bindgen-cli
```

### 打包

#### wasm-pack

一个专门用于打包、发布 wasm 的工具。

### 在 Rust 中调用 JS 的 API

 使用 js-sys 这个 crate 和 web_sys 这个 crate

### 代码体积优化

使用命令行初始化项目

```bash
npm init rust-webpack wasm-rust
或
pnpm create rust-webpack wasm-rust
```

#### 内存分配器

项目中会使用 wee_alloc 这个内存分配器，对比默认的 10kb 的分配器，它只有 1kb 的大小，但是它要比默认的分配器速度要慢，所以默认不开启。

cargo.toml 中加入以下配置，版本号可以使用最新版本

```toml
[dependencies]
wee_alloc = {version = "0.4.2", optional = true}
```

lib.rs 中使用的代码如下：

```rust
#[cfg(feature = "wee_alloc")]
#[global_allocator]
static ALLOC: wee_alloc::WeeAlloc = wee_alloc::WeeAlloc::INIT;
```

#### 打包优化

在 cargo.toml 加上以下配置

```toml
# 0 – no optimizations; also turns on cfg(debug_assertions)
# 1 – basic optimizations 
# 2 – some optimizations 
# 3 – all optimizations 
# s – 优化二进制大小
# z – 优化二进制大小同时关闭循环向量

# 开发环境优化
[profile.dev]
debug = true
# link time optimize LLVM的链接时间优化，false时只会优化当前包，true/fat会跨依赖寻找关系图里的所有包进行优化
# 其它选项还有 off-关闭优化，thin是fat的更快版本
lto = true
opt-level = 'z'

# 生产环境优化
[profile.release]
debug = false
lto = true
opt-level = 'z'
```

#### WASM 内存模型

在 JS 引擎内部，WASM 和 JS 在不同的位置运行。跨越它们之间的边界进行交互是有成本的。浏览器内部用了一些手段来降低这个成本，但是当程序跨越这个边界时，这个行为很快就会成为程序的主要性能瓶颈。以减少边界跨越的方式设计 WASM 程序是很重要。但是一旦程序变大，就很难控制。为了防止边界跨越，WASM 模块附带了内存模型。WASM 模块中的内存是线性内存的向量。线性内存模型是一种内存寻址技术，其中内存被组织在一个块线性地址空间中。它也被称为扁平内存模型。线性内存模型使理解、编程和表示内存变得更容易。但是它也有巨大的缺点，例如重新排列内存中的元素需要大量的执行时间，并且会浪费大量的内存区域。在这里，内存表示一个包含未解释数据的原始字节向量。WASM 使用可调整大小的数组缓冲区来保存内存的原始字节。创建的内存可以从 JS 和 WASM 模块中进行访问和改变。

#### WASM 内存分析

使用 twiggy 这个 crate

```bash
cargo install twiggy
```

使用这个包可以看到相干代码大小占用以及寻找某些编译器不知道如何进行优化的冗余代码

### Show me the code

使用 Rust 来搭建一个可以供 JS 调用的 npm 包，来辅助完成一些事情。

#### 环境搭建

创建 Rust 工程目录

```bash
cargo new example
```

然后在其目录下控制台运行

```
npm init -y
```

package.json 内容如下:

```json
{
  "name": "rust-webpack-template",
  "version": "0.1.0",
  "scripts": {
    "build": "rimraf dist pkg && webpack",
    "start": "rimraf dist pkg && webpack-dev-server",
    "test": "cargo test && wasm-pack test --headless"
  },
  "devDependencies": {
    "@wasm-tool/wasm-pack-plugin": "^1.6.0",
    "copy-webpack-plugin": "^11.0.0",
    "html-webpack-plugin": "^5.5.0",
    "rimraf": "^3.0.2",
    "webpack": "^5.75.0",
    "webpack-cli": "^4.10.0",
    "webpack-dev-server": "^4.11.1"
  }
}
```

cargo.toml 依赖如下

```toml
[package]
authors = []
categories = ["wasm"]
description = ""
edition = "2021"
name = "rust-webpack-template"
readme = "README.md"
version = "0.1.0"

[lib]
crate-type = ["cdylib"]

[features]

[dependencies]
wasm-bindgen = "0.2.83"

wee_alloc = {version = "0.4.5", optional = true}

# 和 JS 的 API 进行交互，比如 DOM
[dependencies.web-sys]
features = ["console"]
version = "0.3.60"

# 提供更好的控制台错误信息，开发时开启，打包时移除
[target."cfg(debug_assertions)".dependencies]
console_error_panic_hook = "0.1.7"

[dev-dependencies]
futures = "0.3.25"
js-sys = "0.3.60"

# 0 – 不优化
# 1 – 基础优化
# 2 – 更多优化
# 3 – 全量优化
# s – 优化二进制大小
# z – 优化二进制大小同时关闭循环向量
[profile.dev]
debug = true
# link time optimize LLVM的链接时间优化，false时只会优化当前包，true/fat会跨依赖寻找关系图里的所有包进行优化
# 其它选项还有 off-关闭优化，thin是fat的更快版本
lto = true
opt-level = 'z'

[profile.release]
debug = false
lto = true
opt-level = 'z'
```

此时的文件夹目录：

![image-20221113180049714](C:\Users\JqWang\AppData\Roaming\Typora\typora-user-images\image-20221113180049714.png)

#### Rust 代码开发

```rust
use wasm_bindgen::prelude::*;
use web_sys;
use web_sys::console;

#[cfg(feature = "wee_alloc")]
#[global_allocator]
static ALLOC: wee_alloc::WeeAlloc = wee_alloc::WeeAlloc::INIT;

#[wasm_bindgen]
pub fn console_log(val: &str) -> () {
    console::log_1(&JsValue::from(val));

    ()
}

// 斐波那契数列，时间复杂度 O(2^n)
#[wasm_bindgen]
pub fn fib(n: i32) -> i32 {
    match n {
        1 | 2 => 1,
        _ => fib(n - 1) + fib(n - 2),
    }
}
```

使用 npm start 启动项目会自动进行编译

项目启动起来后，在 js/index.js 里面使用这个方法，然后就能看到控制台打印的信息了

```js
import("../pkg/index.js")
  .catch(console.error)
  .then((module) => {
    module.console_log("哈哈哈");
    
    // n = 40时， WASM 执行时间大概 0.7s 左右
    const start = performance.now();
    console.log(module.fib(40));
    console.log(((performance.now() - start) / 1000).toFixed(2));
  });

// n = 40 时， JS 执行时间 15s 左右
// 看性能对比
function fib(n) {
  if (n <= 2) return 1;
  return fib(n - 1) + fib(n - 2);
}

const start = performance.now();
console.log(fib(40));
console.log(((performance.now() - start) / 1000).toFixed(2));
```

#### WASM 包发布

cd 到根目录下的 pkg 目录下，然后执行 `npm publish` 就能把包发布到 npm 仓库上，然后在 JS 端 webpack 开启 WASM 实验性配置，就能使用起来了，在一些复杂的计算场景中可以使用 WASM 来提高大量的性能，使用 WASM 之后可以将一些复杂计算逻辑放到客户端来做，这样就能够减少服务器的压力了，节省服务器的一些成本。
