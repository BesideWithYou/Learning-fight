## 第一章 LLVM

所有的 WebAssembly 编译器底层都使用了LLVM去将原生代码（如Rust、C、C++等）转换成 WebAssembly 二进制代码。

### 编译器：

编译器包括三部分:

前端：负责处理源语言

优化器：负责优化代码

后端：负责处理目标语言

### 前端：

前端在接收到代码的时候就会去解析它，然后检查代码是否有语法或语法问题，然后代码就会转换成中间产物（intermediate representation) IR。

### 优化器:

优化器会去分析 IR 并将其转换成更加高效的代码，很少有编译器会有多个中间产物。优化器相当于一个中间产物到中间产物的转换器，其实就是在中间做了一层加工优化处理，优化器包括移除冗余的计算，去掉执行不到的死代码，还有一些其它的可以进行优化的选项。

### 后端：

后端会接收中间产物并转换它到其它语言（如机器码），它也可以链接多个后端去转换代码到一些其它语言。为了产生高效的机器代码，后端应该理解执行代码的体系结构。

### 理解LLVM

LLVM是一个编译器，用于处理LLVM IR。LLVM的核心是负责提供独立于源、目标的优化，并为许多CPU架构生成代码。这使得语言开发人员可以只创建一个前端，从源语言生成LLVM兼容的IR或LLVM IR。

- LLVM使用一种简单的低级语言，看起来类似C语言

- LLVM是强类型的

- LLVM有严格定义的语义

- LLVM具有精确的垃圾回收

- LLVM提供了各种优化，可以根据需求选择。它具有积极的、标量的、过程间的、简单循环的和概要文件驱动的优化
- LLVM提供了各种编译模型。分别是链接时间、安装时间、运行时和脱机
- LLVM为各种目标架构生成机器码
- LLVM提供DWARF调试信息（DWARF是一种调试文件格式，许多编译器和调试器都使用它来支持源代码级别的调试）

LLVM不是一个单一项目。它是子项目和其他项目的集合。这些项目被各种语言使用，比如Ruby，

Python, Haskell, Rust和D编译。

## 第二章 Emscripten

将C/C++编译成WebAssembly的，掠过

## 第三章 探索 WebAssembly 模块

> WebAssembly 的主要目标就是要去构建高效的应用。

它是一个低级别的类汇编语言，设计用于高效执行和紧凑表达，它可以以接近原生代码的速度在所有JS引擎上执行(手机、电脑浏览器、Node.js)。

每个 WebAssembly 文件都是一个高效、最优且自给自足的模块，称为 WebAssembly 模块(WASM)，它运行在沙盒上，内存安全，没有权限获取超出沙盒限制以外的东西。WebAssembly 是一个虚拟指令集结构。

JavaScript 代码的执行过程是：

- 把整个文件加载完成
- 将代码解析成抽象语法树
- 解释器进行解释然后编译再执行
- 最后再进行垃圾回收。

JavaScript既是解释语言又是编译语言，所以 JavaScript 引擎在解析后启动执行。解释器执行代码的速度很快，但它每次解释时都会编译代码，这个阶段称为解释。

JavaScript引擎有监视器(在某些浏览器中称为分析器)。监视器跟踪代码执行情况。如果一个特定的代码块被频繁地执行，那么监视器将其标记为热代码。引擎使用即时(JIT)编译器编译代码块。引擎会花费一些时间进行编译，比如以纳秒为单位。花在这里的时间是值得的，因为下次调用函数时，执行速度会快得多，因为编译版本总是比解释版本快。这个阶段称为优化。

JavaScript引擎增加了一(或两)层优化。监视器继续监视代码执行。监视器标记那些被执行频次更高的代码为非常热门(very hot)的代码，引擎将进一步优化这段代码。这个优化需要很长时间。这个阶段产生运行速度非常快的高度优化过的代码。此代码比之前优化的代码和解释版本要快得多。显然，引擎在这一阶段花费了更多时间，比如以毫秒为单位，这里耗费的时间将由代码性能和执行频率补偿。

JavaScript是一种动态类型的语言，引擎所能做的所有优化都是基于类型的推断。如果推断失败，那么将重新解释并执行代码，并删除优化过的代码，而不是抛出运行时异常。JavaScript引擎实现必要的类型检查，并在推断的类型发生变化时提取优化的代码。但是花在上述代码优化阶段的功夫就白费了。

可以通过使用 TypeScript 来防止这些与类型相关的问题。TypeScript 是 JavaScript 的超集。使用 TypeScript，可以防止多态代码 (接受不同类型的代码)。在JavaScript引擎中，只接受一种类型的代码总是比多态代码运行得快。

最后一步是垃圾回收，将删除内存中的所有活动对象。JavaScript 引擎中的垃圾回收采用标记清除算法。在垃圾回收过程中，JavaScript引擎从根对象 (类似于Node.js中的全局对象) 开始。它查找从根对象引用的所有对象，并将它们标记为可访问对象。它将剩余的对象标记为不可访问的对象。最后清除不可访问的对象
