## 报文信息

请求行常见头部：

- Accept
- Accept-Language
- Accept-Encoding
- Connection
- Cache-Control

状态行常见头部:

- Last-modified

- Etag
- Content-Length
- Connection
- Content-Type

常见编码传输方式：

- gzip:  采用Lempel-Ziv算法及32位循环冗余检测(CRC)
- compress: 由UNIX文件压缩程序compress生成的编码格式，采用Lempel-Ziv-Welch算法
- deflate(zlib)：组合使用zlib及deflate压缩算法生成的
- identity(不进行编码)

发送多种数据的多部份对象集合（图片或文本上传时使用)

Content-Type:

- multipart/form-data  //Web表单上传时使用
- multipart/byteranges //206状态码，响应报文包含了多个范围内的内容

## 状态码

### 类别：

|      | 类别             | 原因短语               |
| ---- | ---------------- | ---------------------- |
| 1xx  | 信息性状态码     | 接收的请求正在处理     |
| 2xx  | 成功状态码       | 请求正常处理完毕       |
| 3xx  | 重定向状态码     | 需要附加操作以完成请求 |
| 4xx  | 客户端错误状态码 | 服务器无法处理请求     |
| 5xx  | 服务端错误状态码 | 服务器处理请求出错     |

### 常见状态码：

#### 1XX继续：

**100 continue：**该状态码说明服务器收到了请求的初始部分，并且请客户端继续发送

#### 2XX成功：

**200 OK：**客户端发来的请求在服务器被正常处理

**204 No Content：**服务器接收的请求正常处理，但返回的响应报文中不含实体的主体部分。比如浏览器发出请求处理后，返回204，浏览器的显示页面不刷新。

**206 Partial Content：**客户端进行了范围请求。响应报文包含有Content-Range指定范围的实体内容

#### 3XX重定向：

**301 Moved Permanently：**永久重定向，表示请求的资源被分配了新的URI，以后请求资源应使用新的URI

**302 Found：**临时重定向，表示请求的资源被分配了新的URI，但是只希望用户本次使用新的URI访问

**303 See Other：**表示请求对应的资源存在另一个URI，应使用GET请求定向获取请求的资源。该状态码和302状态码有相同功能，不同的是它规定客户端应当使用GET请求去获取资源

**304 Not Modified：**该状态码和协商缓存有关，客户端请求服务器询问资源是否改变，如果服务器资源未改变，返回304状态码，客户端可以直接使用未过期的缓存

**307 Temporary Redirect：**临时重定向，和302有着相同的含义。302标准会禁止POST变成GET，但是使用时大家并不遵守，而307会遵照浏览器的标准，不会从POST变成GET。

#### 4XX客户端错误：

**400 Bad Request：**表示请求报文中存在语法错误，需要修改请求的内容后再次发送请求

**401 Unauthorized：**表示发送的请求需要通过有HTTP认证的认证信息

**403 Forbidden：**该状态码表示请求资源的访问被服务器拒绝了，没有访问权限。

**404 Not Found：**表示服务器找不到请求的资源，也可以在服务器拒绝请求且不想说明理由时使用

**417 Expectation failed：**服务器无法理解客户端的期望做出回应而发生错误

#### 5XX服务器错误：

**500 Internal Server Error：**表示服务器在执行请求时发生了错误

**503 Service Unavailable：**服务器暂时处于超负载或进行停机维护，暂时无法处理请求

## HTTP首部

### 4种HTTP首部字段类型

- 通用首部字段：请求报文和响应报文都会用到
- 请求首部字段：客户端向服务端发送请求报文时使用的首部
- 响应首部字段：服务端向客户端返回响应报文时使用的首部
- 实体首部字段：针对请求报文和响应报文的实体部分使用的首部

### 通用首部字段

| 首部字段名        | 说明                       |
| ----------------- | -------------------------- |
| Cache-Control     | 控制缓存行为               |
| Connection        | 逐跳首部、连接的管理       |
| Date              | 创建报文的日期             |
| Pragma            | 报文指令                   |
| Trailer           | 报文末端的首部一览         |
| Transfer-Encoding | 指定报文主体的传输编码方式 |
| Upgrade           | 升级为其它协议             |
| Via               | 代理服务器的相关信息       |
| Warning           | 错误通知                   |

### 请求首部字段

| 首部字段名        | 说明                               |
| ----------------- | ---------------------------------- |
| Accept            | 用户代理可处理的媒体类型           |
| Accept-Charset    | 优先字符集                         |
| Accept-Encoding   | 优先编码内容                       |
| Accept-Language   | 优先语言                           |
| Authorization     | Web认证信息                        |
| Expect            | 期待的服务器特定行为               |
| From              | 用户邮箱地址                       |
| Host              | 请求资源所在服务器                 |
| If-Match          | 比较实体标记（E-tag）              |
| If-Modified-Since | 比较资源更新时间                   |
| If-None-Match     | 比较实体标记(和If-Match)相反       |
| If-Range          | 资源未更新时发送实体Byte的范围请求 |
| Range             | 实体的字节范围请求                 |

### 响应首部字段

| 首部字段名         | 说明                         |
| ------------------ | ---------------------------- |
| Accept-Ranges      | 是否接受字节范围请求         |
| Age                | 推算资源创建经过时间         |
| Etag               | 资源匹配信息                 |
| Location           | 令客户端重定向至指定URI      |
| Proxy-Authenticate | 代理服务器对客户端的认证信息 |
| Retry-After        | 再次发起请求时机的要求       |
| Server             | HTTP服务器的安装信息         |
| Vary               | 代理服务器缓存的管理信息     |

### 实体首部字段

| 首部字段名       | 说明                   |
| ---------------- | ---------------------- |
| Allow            | 资源可支持的HTTP方法   |
| Content-Encoding | 实体主体适用的编码方式 |
| Content-Language | 实体主体的自然语言     |
| Content-Length   | 实体主体的大小         |
| Content-Location | 替代对应资源的URI      |
| Content-MD5      | 实体主体的报文摘要     |
| Content-Range    | 实体主体的位置信息     |
| Content-Type     | 实体主体的媒体信息     |
| Expires          | 实体主体过期的日期时间 |
| Last-Modified    | 资源的最后修改时间     |

### HTTP/1.1 通用首部字段

请求报文和响应报文都会用到的首部就叫通用首部

缓存控制：

```
Cache-Control: private, max-age=0, no-cache
```

缓存请求指令有

| 指令           | 参数   | 说明                                                 |
| -------------- | ------ | ---------------------------------------------------- |
| no-cache       | 无     | 强制向源服务器再次验证资源是否过期，不缓存过期的资源 |
| no-store       | 无     | 不缓存请求或响应的任何内容                           |
| max-age= 秒    | 必需   | 响应的最大age值                                      |
| max-stale = 秒 | 可省略 | 接收已过期的响应                                     |
| min-fresh = 秒 | 必需   | 期望在指定时间内的响应仍有效                         |

缓存响应指令有

| 指令            | 参数   | 说明                                                         |
| --------------- | ------ | ------------------------------------------------------------ |
| public          | 无     | 可向任意方提供响应的缓存                                     |
| private         | 可省略 | 仅向特定用户返回响应                                         |
| no-cache        | 可省略 | 缓存前必须先确认有效性，目的是为了防止从缓存中返回过期的资源。 |
| no-store        | 无     | 不缓存请求或响应的任何内容                                   |
| must-revalidate | 无     | 可缓存但必须再向源服务器进行确认                             |
| max-age = 秒    | 必需   | 响应的最大Age值，用了该字段会忽略Expires字段的处理           |
| s-maxage = 秒   | 必须   | 功能和max-age类似，但是它只用于公共缓存服务器。表示响应的最大Age值，用了该字段会忽略Expires首部字段和max-age指令的处理 |

### Set-Cookie

Set-Cookie字段说明

| 属性         | 说明                                                         |
| ------------ | ------------------------------------------------------------ |
| NAME=VALUE   | 赋予Cookie的名称和其值（必需）                               |
| expires=DATE | Cookie的有效期（不指定则默认未关闭浏览器为止）               |
| path=PATH    | 将服务器上的文件目录作为cookie的适用对象（不指定则默认为文档所在的文件目录) |
| domain=域名  | 作为Cookie适用对象的域名（不指定默认为创建Cookie的服务器的域名） |
| Secure       | 只有在HTTPS时才会发送Cookie                                  |
| HttpOnly     | 加以限制，使Cookie不能被JavaScript访问                       |

##  HTTPS

为什么有了HTTP还需要HTTPS？这就要说说HTTP的缺点了

- 通信使用不加密的明文，内容可能被窃听
- 不验证通信方的身份，可能遭遇伪装
- 无法证明报文完整性，有可能被篡改

### 通信的加密

HTTP中没加密机制，可以通过SSL（安全套接层）或TLS（安全传输协议）组合使用，加密HTTP的通信内容

用SSL建立安全通信线路之后，就可以在这条线路上进行HTTP通信了。与SSL组合使用的HTTP被称为HTTPS。

### 内容的加密

另一种加密方式是将通信的内容本身进行加密，即把HTTP报文里包含的内容进行加密处理。为了做到有效的内容加密，前提要求客户端和服务器同时具备加密和解密机制。该方式不同于SSL或TLS将整个通信线路加密，所以内容还是有被篡改的风险。

### 证书

使用HTTP无法确定通信方，但是使用SSL可以。SSL不仅提供加密处理，还使用了叫做证书的手段，用于验证通信方。证书有值得信任的第三方机构颁发，用以证明服务器和客户端是真实存在的（伪造证书从技术角度来说是异常困难的事情）所以只要能确定通信方持有的证书，即可判断通信方的真实意图。

### HTTP+加密+认证+完整性保护=HTTPS

| 应用（HTTP） |
| ------------ |
| TCP          |
| IP           |

HTTP

| 应用（HTTP） |
| ------------ |
| SSL          |
| TCP          |
| IP           |

HTTPS

HTTPS就是身披SSL协议外壳的HTTP

### 对称加密

加密和解密都用同一个密钥的方式称为对称加密

以对称加密方式加密时必须将密钥也发送给对方。中间攻击者只要拿到密钥，任何人都能破解密码

### 公开密钥加密（非对称加密）

公开密钥加密使用一对非对称密钥。一把叫做私有密钥，另一把叫做公开密钥。私有密钥存放在服务器用来解密，不能让其他人知道。公有密钥可以随意发布。

使用公开密钥，客户端传输数据使用服务端发送来的公开密钥进行加密，服务端收到加密信息后再用自己的私有密钥进行解密。

另外，只使用密文和公开密钥来恢复原文信息是十分困难的，解密过程就是对离散对数进行求值，如果能对一个非常大的整数做到快速地因式分解才有可能破解，但是目前技术很难实现。

### HTTPS采用混合加密制度

HTTPS采用对称加密和非对称加密两者并用的混合加密。非对称加密比对称密钥处理速度慢，解密的过程需要时间。所以在交换密钥的时候使用非对称加密，之后建立通信交换报文阶段就用对称加密。

### 证书安全

非对称加密的方式还是存在一些问题的，就是无法验证公开密钥本身是否是正确的。如何去证明收到的公开密钥是预想服务器发布的公开密钥？公开密钥在传输途中被人替换了怎么办？

解决上述问题就是利用数字证书认证机构（CA）和相关机关颁布的公开密钥证书。

证书如何安全转移是一件很困难的事情，所以多数浏览器开发商发布版本的时候就在浏览器内部植入了常用认证机关的公开密钥。

### 过程

- 服务器把自己的公开密钥登录到数字证书认证机构
- 数字证书认证机构用自己的私有密钥向服务器的公开密码部署数字签名并颁发公钥证书
- 客户端拿到服务器的公钥证书后，使用数字证书认证机构的公开密钥，向数字证书认证机构验证公钥证书上的数字签名，以确认服务器的公开密钥真实性
- 客户端使用服务器的公开密钥对报文加密后发送
- 服务器用私有密钥对报文解密

### 可证明组织真实性的EV SSL证书

用以确认对方服务器背后运营的企业是否真实存在

### 用以确认客户端的客户端证书

获取客户端证书必须要用户自行安装，只有安全性极高的认证机构可颁布客户端证书，且只用于特殊业务，比如网银在登陆时要求用户输入ID和密码，同时还要用户安装客户端证书。但是客户端证书还有个问题就是只能证明客户端实际存在而不能证明用户本人的真实性。

### 自签名证书

独立构建的认证机构叫做自认证机构，由自认证机构颁发的“无用”证书也被戏称为自签名证书

### HTTPS建立过程

P162。在建立过程的流程中，应用层发送数据时会附加一种叫MAC(Message Authentication Code)的报文摘要。MAC可以查知报文是否遭到篡改，从而保护报文的完整性。

### 为什么不一直使用HTTPS？

和纯文本通信比，加密通信会消耗更多CPU和内存资源。如果每次通信都加密会消耗相当多的资源，平摊到一台计算机，能够处理的请求数量必定会随之减少。如果时非敏感信息使用HTTP通信，只有在包含个人信息等敏感数据时，才用HTTPS加密通信。另外，想要节省购买证书的开销也是原因之一。

### 浏览器怎么验证证书的安全性？

CA下发给网站的证书都是一个证书链，也就是一层一层的证书，从根证书开始，到下级CA，一层一层，最后一层就是网站证书。

证书颁发机构，也就是CA，是不会直接向用户签发证书的，而是多了一层中间证书颁发机构。CA会自己给自己签发一个证书，这个证书叫做根证书。然后CA会通过根证书来签发中间证书，授权中间证书颁发机构签发证书的权限；最后中间证书颁发机构通过中间证书向用户签发用户证书。至于为什么需要多这么一层中间证书颁发机构，目的是为了保护根证书，减少根证书被攻击或者说被破解的风险。因为一旦根证书被破解了，根证书所属的CA颁发的所有证书都将失去保护网站的能力，这是一件十分严重的事情。

中间证书可以不止一个，中间证书层数越多，根证书越安全，但是中间证书越多，证书结构越复杂，越占用通信资源。所以一般情况下，用户收到的证书是三个证书（一个根证书、一个中间证书、一个用户证书）或四个证书（一个根证书、两个中间证书、一个用户证书）

### 根证书库，浏览器为什么会信任CA签发的证书呢

CA是可信任的第三方组织，负责证书的生成、签发和作废。为什么CA时可信的呢，因为他们被WebTrust信任。只有通过WebTrust认证的证书颁发机构CA，其签发的证书才会被各大浏览器信任。根证书库包含浏览器信任的证书颁发机构CA的根证书。

用户证书被中间证书信任，而中间证书被根证书信任，根证书又被浏览器信任，这样一个完整的证书链使得浏览器可以在根证书库内一次检索用户证书、中间证书和根证书，如果能匹配到根证书，那么这一信任链上的所有证书都是合法的。

如果用户证书被吊销，浏览器还会显示安全吗？证书颁发机构有个叫做证书作废列表的东西。证书签发以后，如果出现私钥泄露或丢失、证书所有者信息变更、不再需要继续使用证书等情况，证书颁发机构将会对证书进行作废，并将证书的序列号登记在证书作废列表CRL中。浏览器通过查询证书颁发机构CA最新的CRL，可以确定某个证书是否有效。但是，浏览器并不可能在每个访问者访问每个网站时都向CA查询一次，那这工作量也太大了，所以通常浏览器会定期查询CA最新的CRL，这也就会在一定程度上出现，证书被吊销了，浏览器依旧会信任的情况，但是这个是时间不会太久。

如果用户证书没有问题，反而证书颁发机构CA由于安全防护出现问题导致一些机密内容泄露，那么这个CA就不应该被信任，各大浏览器就会将这个CA的根证书从根证书库中删除。这样，该证书签发的所有中间证书和用户证书都将不被信任。

## 用户身份认证

### HTTP使用的认证方式

- BASIC认证（基本认证）
- DIGEST认证（摘要认证）
- SSL客户端认证
- FormBase认证（基于表单认证）

### Session管理和Cookie应用

- 1.客户端把用户ID和密码等登录信息放到报文实体部分，以POST请求发送给服务器
- 2.服务器会发放用以识别用户的Session ID。通过验证从客户端发送过来的登录信息进行身份认证，然后把用户的认证状态和Session ID绑定后记录在服务器端。向客户端响应时会在首部字段Set-Cookie写入Seesion ID。为了防止Session ID被第三方盗走，应使用难以推测的字符串做Session ID，且服务器要进行有效期的管理。为了减少XSS攻击，建议在Cookie加上HttpOnly字段。
- 客户端接收到服务器发送的Session ID后，作为Cookie保存在本地。下次发送请求时会自动带上这个Cookie。服务器通过验证接收到的Session ID识别用户和认证其状态

另外的认证方式是先给密码加盐(salt)，然后再使用散列(hash)函数计算出散列值后再保存。

使用Token的方式进行用户身份验证。

## 基于HTTP的功能追加协议

### 全双工通信WebSocket P187

目前已成为HTML5的标准。一旦Web服务器和客户端建立起WebSocket协议的通信连接，之后所有的通信都依靠这个专用协议进行。通信过程可以互相发送JSON、XML、HTML或图片等任意格式的数据。

WebSocket是建立在HTTP基础上的协议，发起方仍是客户端，一旦建立起WebSocket连接，不论服务器还是客户端都可以直接向对方发送报文

功能

- 推送：服务器向客户端直接推送数据
- 减少通信量：只要建立起WebSocket，就希望一直保持连接。和HTTP相比，不但每次连接时总开销减少了，而且由于WebSocket的首部信息量很小，通信量也减少了。

为了完成WebSocket通信，HTTP的Upgrade首部字段也要变成websocket，以达到握手目的。

### HTTP/2.0

HTTP/2主要是为了解决现HTTP 1.1性能不好的问题才出现的。当初Google为了提高HTTP性能，做出了SPDY，它就是HTTP/2的前身，后来也发展成为HTTP/2的标准。HTTP/2兼容HTTP 1.1。

特点:

- **二进制分帧：**采用二进制格式传输数据，而非 HTTP 1.x 的文本格式，二进制协议解析起来更高效。HTTP/2 将请求和响应数据分割为更小的帧，并且它们采用二进制编码。**同域名下所有通信都在单个连接上完成，该连接可以承载任意数量的双向数据流。**每个数据流都以消息的形式发送，而消息又由一个或多个帧组成。多个帧之间可以乱序发送，根据帧首部的流标识可以重新组装。
- **首部压缩：**HTTP1.1不支持HTTP首部压缩 ，造成了数据较大，降低了传输速度。 在HTTP2.0中，使用了HPACK（头部压缩算法，类似于索引表-js中的数组，每个索引对应一个值， 在传输的时候，不在是传输对应的头部信息了，而是传递索引，对于之前出现过的头部信息，只需要把索引(比如1，2，...)传给对方即可，对方拿到索引查表就行了，比如索引2对应的就是method方法，类似于数组中下标2对应'GET'），使用该算法大大增加了传输速度。
- **多路复用：**复用TCP连接，在一个连接里，客户端和浏览器都可以同时发送多个请求或回应，且不用按顺序一一对应，这样子解决了队头阻塞的问题，也极大提高了传输性能 
- **请求优先级：** 可以设置数据帧的优先级，让服务端先处理重要资源，优化用户体验 。
- **服务端推送：** 服务器可以对一个客户端请求发送多个响应。服务器向客户端推送资源不需要客户端明确的请求 。

### JSON

以JavaScript的对象表示法为基础的轻量级数据标记语言。能够处理的数据类型有null/布尔/对象/数组/数字/字符串这六种类型

## Web攻击技术

## 攻击模式

- 主动攻击：指攻击者通过直接访问Web应用，把攻击代码传入的攻击模式。SQL注入和OS命令注入是常见的攻击方式
- 被动攻击：以服务器为目标的被动攻击，指利用圈套策略执行攻击代码的攻击模式。攻击者不直接对目标Web应用访问发起攻击

### DOS攻击

让运行中的服务呈停止状态的攻击。也叫服务停止攻击或拒绝服务攻击

- 集中利用访问请求造成资源过载，资源用尽的同时，实际上服务也呈停止状态
- 通过攻击安全漏洞使服务停止

### 中间人攻击：

请求或响应在传输途中，遭攻击者拦截并篡改内容的攻击称为中间人攻击

防止篡改手段：采用MD5和SHA-1等散列值校验的方法，以及用来确认文件的数字签名方法。

PGP（完美隐私）是用来证明创建文件的数字签名，MD5是由单向函数生成的散列值。

MD5和PGP都需要用户手动确认下载的文件是否来自原来服务器的文件，无法自动帮用户校验。而且这两种方式如果本身被篡改了，也没办法保证确认结果正确。为了防止这些弊端必须使用HTTPS。

### 跨站脚本攻击XSS



### 跨站点请求伪造CSRF

- 利用已通过认证的用户权限更新设定信息
- 利用已通过认证的用户权限购买商品
- 利用已通过认证的用户权限在留言板上发表言论



### SQL注入攻击

对Web应用使用的数据库，通过运行非法的SQL而产生的攻击。

- 非法查看或篡改数据库中的数据
- 规避认证
- 执行和数据库服务器业务关联的程序

### OS命令注入攻击



## CDN和DNS

1. CDN（Content Delivery Network）即内容分发网络，CDN的作用是使用户可就近取得所需内容，解决 Internet网络拥挤的状况，提高用户访问网站的响应速度。本文介绍CDN的工作过程及工作原理。

   ## CDN的作用

   使用CDN会极大地简化网站的系统维护工作量，网站维护人员只需将网站内容注入CDN的系统，通过CDN部署在各个物理位置的服务器进行全网分发，就可以实现跨运营商、跨地域的用户覆盖。CDN将内容推送到网络边缘，大量的用户访问被分散在网络边缘，不再构成网站出口、互联互通点的资源挤占，也不再需要跨越长距离IP路由，即减少了源服务器的资源占用，企业大大提升了用户访问的响应时间，提高用户体验。

   ## 没有CDN网站的工作原理

   ①用户在自己的浏览器中输入要访问的网站域名。

   ②浏览器向本地DNS服务器请求对该域名的解析。

   ③本地DNS服务器中如果缓存有这个域名的解析结果，则直接响应用户的解析请求。

   ④本地DNS服务器中如果没有关于这个域名的解析结果的缓存，则以递归或迭代方式向整个DNS系统请求解析，获得应答后将结果反馈给浏览器。

   ⑤浏览器得到域名解析结果，就是该域名相应的服务设备的IP地址。

   ⑥浏览器向服务器请求内容。

   ⑦服务器将用户请求内容传送给浏览器。

   ## 网站接入CDN后工作流程及工作原理

   网站接入CDN后，构建了CDN网络，这个CDN网络一般是由一个DNS服务器和几台缓存服务器运行起来的。

   [![CDN工作原理](https://www.aliyunbaike.com/wp-content/uploads/2018/01/cdn.jpg)](https://www.aliyunbaike.com/wp-content/uploads/2018/01/cdn.jpg)

   CDN工作原理

   
   ①当用户点击网站页面上的内容URL，经过本地DNS系统解析，DNS系统会最终将域名的解析权交给CNAME指向的CDN专用DNS服务器。

   ②CDN的DNS服务器将CDN的全局负载均衡设备IP地址返回用户。

   ③用户向CDN的全局负载均衡设备发起内容URL访问请求。

   ④CDN全局负载均衡设备根据用户IP地址，以及用户请求的内容URL，选择一台用户所属区域的区域负载均衡设备，告诉用户向这台设备发起请求。

   ⑤区域负载均衡设备会为用户选择一台合适的缓存服务器提供服务，选择的依据包括：根据用户IP地址，判断哪一台服务器距用户最近；根据用户所请求的URL中携带的内容名称，判断哪一台服务器上有用户所需内容；查询各个服务器当前的负载情况，判断哪一台服务器尚有服务能力。基于以上这些条件的综合分析之后，区域负载均衡设备会向全局负载均衡设备返回一台缓存服务器的IP地址。

   ⑥全局负载均衡设备把服务器的IP地址返回给用户。

   ⑦用户向缓存服务器发起请求，缓存服务器响应用户请求，将用户所需内容传送到用户终端。如果这台缓存服务器上并没有用户想要的内容，而区域均衡设备依然将它分配给了用户，那么这台服务器就要向它的上一级缓存服务器请求内容，直至追溯到网站的源服务器将内容拉到本地。

   DNS服务器根据用户IP地址，将域名解析成相应节点的缓存服务器IP地址，实现用户就近访问。使用CDN服务的网站，只需将其域名解析权交给CDN的GSLB设备，将需要分发的内容注入CDN，就可以实现网站内容加速。