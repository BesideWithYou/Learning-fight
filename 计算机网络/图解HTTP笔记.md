## 第三章 报文信息

请求行常见头部：

- Accept
- Accept-Language
- Accept-Encoding
- Connection
- Cache-Control

状态行常见头部:

- Last-modified

- Etag
- Content-Length
- Connection
- Content-Type

常见编码传输方式：

- gzip:  采用Lempel-Ziv算法及32位循环冗余检测(CRC)
- compress: 由UNIX文件压缩程序compress生成的编码格式，采用Lempel-Ziv-Welch算法
- deflate(zlib)：组合使用zlib及deflate压缩算法生成的
- identity(不进行编码)

发送多种数据的多部份对象集合（图片或文本上传时使用)

Content-Type:

- multipart/form-data  //Web表单上传时使用
- multipart/byteranges //206状态码，响应报文包含了多个范围内的内容

## 第四章 状态码

### 类别：

|      | 类别             | 原因短语               |
| ---- | ---------------- | ---------------------- |
| 1xx  | 信息性状态码     | 接收的请求正在处理     |
| 2xx  | 成功状态码       | 请求正常处理完毕       |
| 3xx  | 重定向状态码     | 需要附加操作以完成请求 |
| 4xx  | 客户端错误状态码 | 服务器无法处理请求     |
| 5xx  | 服务端错误状态码 | 服务器处理请求出错     |

### 常见状态码：

#### 2XX成功：

200 OK：客户端发来的请求在服务器被正常处理

204 No Content：服务器接收的请求正常处理，但返回的响应报文中不含实体的主体部分。比如浏览器发出请求处理后，返回204，浏览器的显示页面不刷新。

206 Partial Content：客户端进行了范围请求。响应报文包含有Content-Range指定范围的实体内容

#### 3XX重定向：

301 Moved Permanently：永久重定向，表示请求的资源被分配了新的URI，以后请求资源应使用新的URI

302 Found：临时重定向，表示请求的资源被分配了新的URI，但是只希望用户本次使用新的URI访问

303 See Other：表示请求对应的资源存在另一个URI，应使用GET请求定向获取请求的资源。该状态码和302状态码有相同功能，不同的是它规定客户端应当使用GET请求去获取资源

304 Not Modified：该状态码和协商缓存有关，客户端请求服务器询问资源是否改变，如果服务器资源未改变，返回304状态码，客户端可以直接使用未过期的缓存

307 Temporary Redirect：临时重定向，和302有着相同的含义。302标准会禁止POST变成GET，但是使用时大家并不遵守，而307会遵照浏览器的标准，不会从POST变成GET。

#### 4XX客户端错误：

400 Bad Request：表示请求报文中存在语法错误，需要修改请求的内容后再次发送请求

401 Unauthorized：表示发送的请求需要通过有HTTP认证的认证信息

403 Forbidden：该状态码表示请求资源的访问被服务器拒绝了，没有访问权限。

404 Not Found：表示服务器找不到请求的资源，也可以在服务器拒绝请求且不想说明理由时使用

417 Expectation failed：服务器无法理解客户端的期望做出回应而发生错误

#### 5XX服务器错误：

500 Internal Server Error：表示服务器在执行请求时发生了错误

503 Service Unavailable：服务器暂时处于超负载或进行停机维护，暂时无法处理请求

## 第六章 HTTP首部

### 4种HTTP首部字段类型

- 通用首部字段：请求报文和响应报文都会用到
- 请求首部字段：客户端向服务端发送请求报文时使用的首部
- 响应首部字段：服务端向客户端返回响应报文时使用的首部
- 实体首部字段：针对请求报文和响应报文的实体部分使用的首部

### 通用首部字段

| 首部字段名        | 说明                       |
| ----------------- | -------------------------- |
| Cache-Control     | 控制缓存行为               |
| Connection        | 逐跳首部、连接的管理       |
| Date              | 创建报文的日期             |
| Pragma            | 报文指令                   |
| Trailer           | 报文末端的首部一览         |
| Transfer-Encoding | 指定报文主体的传输编码方式 |
| Upgrade           | 升级为其它协议             |
| Via               | 代理服务器的相关信息       |
| Warning           | 错误通知                   |

### 请求首部字段

| 首部字段名        | 说明                               |
| ----------------- | ---------------------------------- |
| Accept            | 用户代理可处理的媒体类型           |
| Accept-Charset    | 优先字符集                         |
| Accept-Encoding   | 优先编码内容                       |
| Accept-Language   | 优先语言                           |
| Authorization     | Web认证信息                        |
| Expect            | 期待的服务器特定行为               |
| From              | 用户邮箱地址                       |
| Host              | 请求资源所在服务器                 |
| If-Match          | 比较实体标记（E-tag）              |
| If-Modified-Since | 比较资源更新时间                   |
| If-None-Match     | 比较实体标记(和If-Match)相反       |
| If-Range          | 资源未更新时发送实体Byte的范围请求 |
| Range             | 实体的字节范围请求                 |

### 响应首部字段

| 首部字段名         | 说明                         |
| ------------------ | ---------------------------- |
| Accept-Ranges      | 是否接受字节范围请求         |
| Age                | 推算资源创建经过时间         |
| Etag               | 资源匹配信息                 |
| Location           | 令客户端重定向至指定URI      |
| Proxy-Authenticate | 代理服务器对客户端的认证信息 |
| Retry-After        | 再次发起请求时机的要求       |
| Server             | HTTP服务器的安装信息         |
| Vary               | 代理服务器缓存的管理信息     |

### 实体首部字段

| 首部字段名       | 说明                   |
| ---------------- | ---------------------- |
| Allow            | 资源可支持的HTTP方法   |
| Content-Encoding | 实体主体适用的编码方式 |
| Content-Language | 实体主体的自然语言     |
| Content-Length   | 实体主体的大小         |
| Content-Location | 替代对应资源的URI      |
| Content-MD5      | 实体主体的报文摘要     |
| Content-Range    | 实体主体的位置信息     |
| Content-Type     | 实体主体的媒体信息     |
| Expires          | 实体主体过期的日期时间 |
| Last-Modified    | 资源的最后修改时间     |

### HTTP/1.1 通用首部字段

请求报文和响应报文都会用到的首部就叫通用首部

缓存控制：

```
Cache-Control: private, max-age=0, no-cache
```

缓存请求指令有

| 指令           | 参数   | 说明                                                 |
| -------------- | ------ | ---------------------------------------------------- |
| no-cache       | 无     | 强制向源服务器再次验证资源是否过期，不缓存过期的资源 |
| no-store       | 无     | 不缓存请求或响应的任何内容                           |
| max-age= 秒    | 必需   | 响应的最大age值                                      |
| max-stale = 秒 | 可省略 | 接收已过期的响应                                     |
| min-fresh = 秒 | 必需   | 期望在指定时间内的响应仍有效                         |

缓存响应指令有

| 指令            | 参数   | 说明                                                         |
| --------------- | ------ | ------------------------------------------------------------ |
| public          | 无     | 可向任意方提供响应的缓存                                     |
| private         | 可省略 | 仅向特定用户返回响应                                         |
| no-cache        | 可省略 | 缓存前必须先确认有效性，目的是为了防止从缓存中返回过期的资源。 |
| no-store        | 无     | 不缓存请求或响应的任何内容                                   |
| must-revalidate | 无     | 可缓存但必须再向源服务器进行确认                             |
| max-age = 秒    | 必需   | 响应的最大Age值，用了该字段会忽略Expires字段的处理           |
| s-maxage = 秒   | 必须   | 功能和max-age类似，但是它只用于公共缓存服务器。表示响应的最大Age值，用了该字段会忽略Expires首部字段和max-age指令的处理 |

### Set-Cookie

Set-Cookie字段说明

| 属性         | 说明                                                         |
| ------------ | ------------------------------------------------------------ |
| NAME=VALUE   | 赋予Cookie的名称和其值（必需）                               |
| expires=DATE | Cookie的有效期（不指定则默认未关闭浏览器为止）               |
| path=PATH    | 将服务器上的文件目录作为cookie的适用对象（不指定则默认为文档所在的文件目录) |
| domain=域名  | 作为Cookie适用对象的域名（不指定默认为创建Cookie的服务器的域名） |
| Secure       | 只有在HTTPS时才会发送Cookie                                  |
| HttpOnly     | 加以限制，使Cookie不能被JavaScript访问                       |

##  第七章 HTTPS

为什么有了HTTP还需要HTTPS？这就要说说HTTP的缺点了

- 通信使用不加密的明文，内容可能被窃听
- 不验证通信方的身份，可能遭遇伪装
- 无法证明报文完整性，有可能被篡改

### 通信的加密

HTTP中没加密机制，可以通过SSL（安全套接层）或TLS（安全传输协议）组合使用，加密HTTP的通信内容

用SSL建立安全通信线路之后，就可以在这条线路上进行HTTP通信了。与SSL组合使用的HTTP被称为HTTPS。

### 内容的加密

另一种加密方式是将通信的内容本身进行加密，即把HTTP报文里包含的内容进行加密处理。为了做到有效的内容加密，前提要求客户端和服务器同时具备加密和解密机制。该方式不同于SSL或TLS将整个通信线路加密，所以内容还是有被篡改的风险。

### 证书

使用HTTP无法确定通信方，但是使用SSL可以。SSL不仅提供加密处理，还使用了叫做证书的手段，用于验证通信方。证书有值得信任的第三方机构颁发，用以证明服务器和客户端时真实存在的（伪造证书从技术角度来说是异常困难的事情）所以只要能确定通信方持有的证书，即可判断通信方的真实意图。

### HTTP+加密+认证+完整性保护=HTTPS

| 应用（HTTP） |
| ------------ |
| TCP          |
| IP           |

HTTP



| 应用（HTTP） |
| ------------ |
| SSL          |
| TCP          |
| IP           |

HTTPS

HTTPS就是身披SSL协议外壳的HTTP

### 对称加密

加密和解密都用同一个密钥的方式称为对称加密

以对称加密方式加密时必须将密钥也发送给对方。中间攻击者只要拿到密钥，任何人都能破解密码

### 公开密钥加密（非对称加密）

公开密钥加密使用一对非对称密钥。一把叫做私有密钥，另一把叫做公开密钥。私有密钥存放在服务器用来解密，不能让其他人知道。公有密钥可以随意发布。

使用公开密钥，客户端传输数据使用服务端发送来的公开密钥进行加密，服务端收到加密信息后再用自己的私有密钥进行解密。

另外，只使用密文和公开密钥来恢复原文信息是十分困难的，解密过程就是对离散对数进行求值，如果能对一个非常大的整数做到快速地因式分解才有可能破解，但是目前技术很难实现。

### HTTPS采用混合加密制度

HTTPS采用对称加密和非对称加密两者并用的混合加密。非对称加密比对称密钥处理速度慢，解密的过程需要时间。所以在交换密钥的时候使用非对称加密，之后建立通信交换报文阶段就用对称加密。

### 证书安全

非对称加密的方式还是存在一些问题的，就是无法验证公开密钥本身是否是正确的。如何去证明收到的公开密钥是预想服务器发布的公开密钥？公开密钥在传输途中被人替换了怎么办？

解决上述问题就是利用数字证书认证机构（CA）和相关机关颁布的公开密钥证书。

证书如何安全转移是一件很困难的事情，所以多数浏览器开发商发布版本的时候就在浏览器内部植入了常用认证机关的公开密钥。

### 过程

- 服务器把自己的公开密钥登录到数字证书认证机构
- 数字证书认证机构用自己的私有密钥向服务器的公开密码部署数字签名并颁发公钥证书
- 客户端拿到服务器的公钥证书后，使用数字证书认证机构的公开密钥，向数字证书认证机构验证公钥证书上的数字签名，以确认服务器的公开密钥真实性
- 客户端使用服务器的公开密钥对报文加密后发送
- 服务器用私有密钥对报文解密

### 可证明组织真实性的EV SSL证书

用以确认对方服务器背后运营的企业是否真实存在

### 用以确认客户端的客户端证书

获取客户端证书必须要用户自行安装，只有安全性极高的认证机构可颁布客户端证书，且只用于特殊业务，比如网银在登陆时要求用户输入ID和密码，同时还要用户安装客户端证书。但是客户端证书还有个问题就是只能证明客户端实际存在而不能证明用户本人的真实性。

### 自签名证书

独立构建的认证机构叫做自认证机构，由自认证机构颁发的“无用”证书也被戏称为自签名证书

### HTTPS建立过程

P162。在建立过程的流程中，应用层发送数据时会附加一种叫MAC(Message Authentication Code)的报文摘要。MAC可以查知报文是否遭到篡改，从而保护报文的完整性。

### 为什么不一直使用HTTPS？

和纯文本通信比，加密通信会消耗更多CPU和内存资源。如果每次通信都加密会消耗相当多的资源，平摊到一台计算机，能够处理的请求数量必定会随之减少。如果时非敏感信息使用HTTP通信，只有在包含个人信息等敏感数据时，才用HTTPS加密通信。另外，想要节省购买证书的开销也是原因之一。



## 攻击

### DOS攻击：

### 中间人攻击：

请求或响应在传输途中，遭攻击者拦截并篡改内容的攻击称为中间人攻击

防止篡改手段：采用MD5和SHA-1等散列值校验的方法，以及用来确认文件的数字签名方法。

PGP（完美隐私）是用来证明创建文件的数字签名，MD5是由单向函数生成的散列值。

MD5和PGP都需要用户手动确认下载的文件是否来自原来服务器的文件，无法自动帮用户校验。而且这两种方式如果本身被篡改了，也没办法保证确认结果正确。为了防止这些弊端必须使用HTTPS。