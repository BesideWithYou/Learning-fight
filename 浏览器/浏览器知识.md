### 浏览器架构

Chrome 正在经历架构变革，它转变为将浏览器程序的每一模块作为一个服务来运行，从而可以轻松实现进程的拆解或聚合。具体表现是，当 Chrome 运行在**「强力硬件」**上时，它会将每个服务分解到不同进程中，从而**「提升稳定性」**，但是如果 Chrome 运行在资源有限的设备上时，它会将服务聚合到一个进程中从而**「节省了内存占用」**。在这一架构变革实现前，类似的整合进程以减少内存使用的方法已经在 Android 类平台上使用。

在 **「V8 出现之前，所有的 JavaScript 虚拟机所采用的都是解释执行的方式，这是 JavaScript 执行速度过慢的一个主要原因」**。而 V8 率先引入了**「即时编译（JIT的双轮驱动」**的设计（混合使用编译器和解释器的技术），这是一种权衡策略，**「混合编译执行和解释执行这两种手段」**，给 JavaScript 的执行速度带来了极大的提升。V8 出现之后，各大厂商也都在自己的 JavaScript 虚拟机中引入了 JIT 机制，所以目前市面上 JavaScript 虚拟机都有着类似的架构。另外，**「V8 也是早于其他虚拟机引入了惰性编译、内联缓存、隐藏类等机制，进一步优化了 JavaScript 代码的编译执行效率」**。

### V8引擎执行JS过程

**「V8 执行一段 JavaScript 代码所经历的主要流程」**包括：

- 初始化基础环境；
- 解析源码生成 AST 和作用域；
- 依据 AST 和作用域生成字节码；
- 解释执行字节码；
- 监听热点代码；
- 优化热点代码为二进制的机器代码；
- 反优化生成的二进制机器代码。

### 主流的浏览器引擎

主流的 JS Engine 是苹果的 JavaScriptCore 和谷歌的 V8，主流的渲染引擎是苹果的 Webkit 和谷歌的 Blink。要实现客户端和网页双向通讯的话，一般都是借助 **JSBridge** 进行通信。

JSBridge 只是解决了 Native 和 Web 的互相调用问题，如果我想借助 Native 加强 Web 怎么办？这时候就有了一些探索：

预热：提前创建和初始化 WebView，甚至实现 WebView 容器池，减少 WebView 的启动时间

缓存：把常用的 Web 资源预先存在 Native 本地，然后拦截浏览器网络请求重定向到本地，这样就可以加快 Web 的资源加载速度（也叫“离线包”方案）；

劫持：比如说 Web 对网络加载的控制力比较弱，部分有能力的厂商会把所有的网络请求都劫持下来交给 Native 去做，这样做可以更灵活的管理 Web 请求，淘宝内部用的Mtop网络请求包其实就是这个原理。

替换：替换一般指替换 Web 的 Img 标签和 Video 标签，这个最常见的地方就是各大新闻类客户端。因为新闻的动态性和实时性，新闻都是由各个编辑/自媒体通过后台编辑下发的，这时候要利用 Web 强大的排版功能去显示文本内容；但是为了加载速度和观看体验，图片和视频都是 Native 组件替换的。

关于JS Bridge的知识可以看这里[JSBridge原理](https://juejin.cn/post/6844903585268891662)

