### 装饰器概念

它是一种特殊类型的声明，它能够被附加到类声明，方法，属性或参数上，可以修改类的行为。
通俗的**讲装饰器就是一个方法**，可以注入到类、方法、属性参数上来扩展类、属性、方法、参数的功能。
常见的装饰器有：

- 类装饰器
- 属性装饰器
- 方法装饰器
- 参数装饰器

装饰器的写法：普通装饰器(无法传参)、装饰器工厂(可传参)

### 类装饰器

类装饰器在类声明之前被声明〈紧靠着类声明)。类装饰器应用于类构造函数，可以用来监视，修改或替换类定义。传入一个参数

#### 普通装饰器：不能传参

```typescript
/**
 * 装饰器
 * target属性就是使用装饰器的那个类
*/
function logClass(target: any) {
  target.prototype.apiUrl = 'http://www.baidu.com'
  target.prototype.hello = () => {
    console.log("hello world")
  }
}

@logClass
class HttpClient {
  constructor() { }
}

const http: any = new HttpClient()

console.log(http.apiUrl) // http://www.baidu.com
http.hello() //hello world
```

#### 装饰器工厂：可以传参

```typescript
/**
 * 装饰器工厂
 * params就是我们要传递的参数
 * target就是要使用装饰器的那个类
 */
function logClass(params: string) {
  return function (target: any) {
    target.prototype.hello = () => {
      console.log(params)
    }
  }
}

@logClass('hello world')
class HttpClient {
  constructor() { }
}

const http: any = new HttpClient()
http.hello()  //打印hello world
```

#### 重载构造函数

类装饰器表达式会在运行时当作函数被调用，类的构造函数作为其唯一的参数。如果类装饰器返回一个值，它会使用提供的构造函数来替换类的声明

```typescript
function logClass(target: any) {
  return class extends target {
    apiUrl: string = '修改后的apiUrl'
    getData() {
      console.log('修改:', this.apiUrl)
    }
  }
}

@logClass
class HttpClient {
  public apiUrl: string | undefined
  constructor() {
    this.apiUrl = '没修改前的apiUrl'
  }

  getData() {
    console.log(this.apiUrl)
  }
}

const http = new HttpClient()
http.getData() //修改: 修改后的apiUrl
```

### 属性装饰器

属性装饰器表达式会在运行时当作函数被调用，传入下列2个参数:

- 装饰的实例。对于静态成员来说是类的构造函数，对于实例成员是类的原型对象 
- 装饰的属性名

```typescript
/**
 * 属性装饰器
 * params就是装饰器传入的参数
 * target就是装饰的实例
 * attr就是装饰的属性
 */
function logProperty(params: any) {
  return function (target: any, attr: any) {
    //通过这样的方式就可以通过装饰器来修改属性值
    target[attr] = params
  }
}

class HttpClient {
  @logProperty('属性装饰器赋值')
  public apiUrl: string | undefined
  constructor() {
  }

  getData() {
    console.log(this.apiUrl)
  }
}

const http = new HttpClient()
http.getData() // 属性装饰器赋值
```

### 方法装饰器

它会被应用到方法的属性描述符上，可以用来监视，修改或者替换方法定义。方法装饰会在运行时传入下列个参数:

- 对于静态成员来说是类的构造函数，对于实例成员是类的原型对象
- 成员的名字
- 成员的属性描述符

```typescript
/**
 * params 传递给装饰器的值
 * target 装饰器的实例
 * methodName 方法名称
 * desc 描述
 */
function get(params: any) {
  return function (target: any, methodName: string, desc: PropertyDescriptor) {
    let originalMethod = desc.value

    //重写传入的方法
    desc.value = function (...args: any[]) {
      console.log(args)
    }
  }
}

class HttpClient {
  public apiUrl: string | undefined
  constructor() {
  }
  @get('http://www.baidu.com')
  getApi() {
    console.log(this.apiUrl)
  }
}

const http = new HttpClient()

http.getApi('haha', 'xixixi')  //打印['haha', 'xixixi']
```

### 装饰器的执行顺序

- 属性 > 方法 > 方法参数 > 类
- 如果有多个同样的装饰器，它会先执行后面的

