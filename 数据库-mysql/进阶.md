## 存储引擎

### MySQL体系结构

连接层：客户端和连接服务，主要做连接处理、验证授权及相关的安全方案。

↓

服务层：做核心功能服务，如SQL接口，并完成缓存的查询，SQL的分析和优化，部分内置函数的执行。

↓

引擎层（可插拔） 索引在该层实现， InnoDB是5.5版本之后默认的存储引擎。负责MySQL 中数据的存储和提取，服务器通过 API 和存储引擎进行通信。

↓

存储层：主要是将数据存储在文件系统之上，并完成和存储引擎的交互。

### 存储引擎简介

存储引擎就是存储数据、建立索引、更新/查询数据等技术的实现方式。存储引擎是基于表的，而不是基于库的，存储引擎也被称为表类型。

创建表时，可以指定存储引擎

```sql
CREATE TABLE 表名(
  ...
) ENGINE = INNODB [COMMENT 表注释];
```

### 存储引擎特点

#### InnoDB

它是一种兼顾高可靠性和高性能的通用存储引擎

特点：DML操作遵循ACID模型，支持事务；

行级锁，提高并发访问性能；

支持外键保证数据的完整性和正确性；

逻辑存储结构：表空间、段、区、页、行

#### MyISAM

MySQL早期默认存储引擎

特点：不支持事务、不支持外键；

支持表锁、不支持行锁；

访问速度快

#### Memory

数据存在内存中，断电后数据不在了，只能作为临时表或缓存使用

特点：内存存放，默认使用 hash 索引

#### 主要区别

事务、锁机制、外键	

| 特点         | InnoDB        | MyISAM | Memory |
| ------------ | ------------- | ------ | ------ |
| 存储限制     | 64TB          | 有     | 有     |
| 事务安全     | **支持**      | -      | -      |
| 锁机制       | **行锁**      | 表锁   | 表锁   |
| B+Tree索引   | 支持          | 支持   | 支持   |
| Hash索引     | -             | -      | 支持   |
| 全文索引     | 5.6版本后支持 | 支持   | -      |
| 空间使用     | 高            | 低     | N/A    |
| 内存使用     | 高            | 低     | 中等   |
| 批量插入速度 | 低            | 高     | 高     |
| 支持外键     | **支持**      | -      | -      |

#### 如何选择

InnoDB：如果对事务的完整性有比较高的要求，在并发条件下要求数据的一致性，数据操作除了插入和查询之外，还包含很多更新、删除操作，适合选择它

MyISAM：如果以读操作和插入操作为主，有少量的更新和删除操作，对事务完整性、并发性要求不高，适合选择它。但是真正业务中一般用 MongoDB 来替代了，一般评论可以用 MongoDB。

MEMORY：数据放在内存中，访问速度快，但是缺陷是对表的大小有限制，太大的表放不进内存，而且不能保证数据安全性。一般业务中都会用 Redis 来替代，一般购物车可以用Redis。

## 索引（重点）

### 概念

帮助 MySQL 高效获取数据的数据结构（有序）。在数据之外，数据库系统还维护者满足特定查找算法的数据结构，这些数据结构以某种方式指向数据，这样就可以在这些数据结构之上实现高级查找算法，这种数据结构就是索引。

说白了，索引就是一个数据结构，用来提高查找速度。

### 优缺点

| 优点                                                         | 缺点                                                         |
| ------------------------------------------------------------ | ------------------------------------------------------------ |
| 提高数据检索效率，降低数据库IO成本                           | 索引列也是占用空间的（存在磁盘，磁盘很便宜，该缺点一般可以忽略） |
| 通过索引列对数据进行排序，降低数据排        序的成本，降低CPU消耗 | 索引大大提高了查询效率，同时也降低了更新表的速度，如对表进行插入、更新、删除时，效率会降低 |

### 索引结构

索引在第三层引擎层实现，在不同的存储引擎会有不同的结构，主要包含：

| 索引结构            | 描述                                                         |
| ------------------- | ------------------------------------------------------------ |
| B+Tree索引          | 最常见的索引，大部分引擎都支持                               |
| Hash索引            | 底层数据结构就是哈希表实现的，只有精确匹配索引列的查询才有效，不支持范围查询 |
| R-tree(空间索引)    | 空间索引是MySAM引擎的一种特殊索引类型，主要用于地理空间数据类型，使用较少 |
| Full-text(全文索引) | 通过建立倒排索引，快速匹配文档的方式                         |

通常说的索引，没特别说明都指的是 B+ Tree

### B-Tree

二叉树具有缺点：顺序插入时，会形成一个链表，查询性能大大降低。大数据量情况下，层级较深，检索速度慢

```
			36
		  34
		33
      32
    23
  22
17
```

红黑树：大数据量的情况下，层级较深，检索速度慢。（红黑树是C++的 Set 和 Map 容器的底层实现）



B树（多路平衡查找树）

以一棵最大度数为 5 (5阶) 的 b-tree 为例（每个节点最多存储 4 个 key，5个指针）。

> 树的度数指的是一个节点的子节点个数

演变过程可以去看这个网站：https://www.cs.usfca.edu/~galles/visualization/Algorithms.html

### B+ Tree

以一棵最大度数为 4 的 B+ Tree 为例：

和 B-Tree 的区别：

所有的数据都会出现在叶子节点

叶子节点会形成一个单向链表

MySQL 索引数据结构对经典的 B+ Tree 进行了优化，增加了一个指向相邻叶子节点的链表指针，形成了带有顺序指针的B+ Tree，提高区间访问性能，其实就是变成了循环双向链表。

### Hash

哈希索引就是采用一定的哈希算法，将键值换算成新的 hash 值，映射到对应的槽位上，然后存储在 hash 表中。

如果两个或多个键值，映射到了同一个相同的槽位，就产生了 hash 冲突，可以通过链表来解决。

特点：

只能用于对等比较（=， in )，不支持范围查询 (between, < , >)

无法利用索引完成排序

查询效率高，通常只需要一次检索就可以了（没有冲突的情况下），效率通常高于 B+ Tree 索引。

### 思考

为什么InnoDB选择 B+ Tree 索引

相对于二叉树，层级更少，搜索效率更高；

对与 B-Tree，无论叶子还是非叶子节点都会保存数据，当一页中存储的键值减少，指针也跟着减少，要同样保存大量数据时， B-Tree 只能增加树的高度，导致性能降低；

相对 Hash 索引，B+ Tree 支持范围匹配和排序操作；