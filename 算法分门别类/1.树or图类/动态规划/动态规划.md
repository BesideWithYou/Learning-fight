## 解法

核心思想是数学归纳法

算法演进的过程就是从i = 0 开始遍历dp数组，通过dp[0...i-1]来推导出dp[i]

**只要是子序列的问题都能用动态规划**

## 子串题目

### 300.（不连续）最长递增子序列

给你一个整数数组 nums ，找到其中最长严格递增子序列的长度。

子序列是由数组派生而来的序列，删除（或不删除）数组中的元素而不改变其余元素的顺序。例如，[3,6,2,7] 是数组 [0,3,1,6,2,2,7] 的子序列。

```
输入：nums = [10,9,2,5,3,7,101,18]
输出：4
解释：最长递增子序列是 [2,3,7,101]，因此长度为 4 。
```

```js
```

### 1143（不连续）最长公共子序列



### 1035（不连续）不相交的线



### 674 （连续）最长连续递增序列

### 718 （连续）最长重复子数组

### 53 （连续） 最大子序和



### 392 （编辑距离） 判断子序列



### 115 （编辑距离）不同的子序列



### 583（编辑距离）两个字符串的删除操作



### 647（回文） 回文子串



### 516（回文）最长回文子序列



## 其它题目

### 爬楼梯

假设你正在爬楼梯。需要 n 阶你才能到达楼顶。

每次你可以爬 1 或 2 个台阶。你有多少种不同的方法可以爬到楼顶呢？

注意：给定 n 是一个正整数。

```
输入： 2
输出： 2
解释： 有两种方法可以爬到楼顶。
1.  1 阶 + 1 阶
2.  2 阶

输入： 3
输出： 3
解释： 有三种方法可以爬到楼顶。
1.  1 阶 + 1 阶 + 1 阶
2.  1 阶 + 2 阶
3.  2 阶 + 1 阶
```

```javascript
/**
 * @param {number} n
 * @return {number}
 */
var climbStairs = function (n) {
    //注意，n是一个正整数，所以不要考虑0！
    if (n <= 1) return n
    const dp = []
    dp[1] = 1
    dp[2] = 2
    for (let i = 3; i <= n; i++) {
        dp[i] = dp[i - 1] + dp[i - 2]
    }

    return dp[n]
};
```

### 兑换零钱

给定不同面额的硬币 coins 和一个总金额 amount。编写一个函数来计算可以凑成总金额所需的最少的硬币个数。如果没有任何一种硬币组合能组成总金额，返回 -1。

你可以认为每种硬币的数量是无限的。

```js
//自顶向下解法
var coinChange = function (coins, amount) {
    const memo = {} //备忘录

    //输入一个目标金额n，返回凑出目标金额n的最少硬币数
    function dp(n) {
        if (memo[n]) return memo[n]
        if (n < 0) return -1
        if (n === 0) return 0
        let res = Infinity

        for (let coin of coins) {
            let subproblem = dp(n - coin)
            if (subproblem === -1) continue
            res = Math.min(res, 1 + subproblem)
        }
        memo[n] = res !== Infinity ? res : -1
        return memo[n]
    }

    return dp(amount)
};

//自底向上解法
var coinChange = function (coins, amount) {
    //dp数组定义：当目标金额为i时，至少需要dp[i]枚硬币凑出
    //初始化一个数组长度为amount+1,里面的值都是Infinity
    const dp = new Array(amount + 1).fill(Infinity)

    dp[0] = 0
    for (let i = 0; i < dp.length; i++) {
        for (let coin of coins) {
            if (i - coin < 0) continue
            dp[i] = Math.min(dp[i], 1 + dp[i - coin])
        }
    }
    return (dp[amount] === Infinity) ? -1 : dp[amount]
};
```

### 背包问题



### 连续子数组最大和

输入一个整型数组，数组中的一个或连续多个整数组成一个子数组。求所有子数组的和的最大值。

要求时间复杂度为O(n)。

```
输入: nums = [-2,1,-3,4,-1,2,1,-5,4]
输出: 6
解释: 连续子数组 [4,-1,2,1] 的和最大，为 6。
```

```javascript
var maxSubArray = function (nums) {
    let sum = 0
    let res = nums[0]
    for (let num of nums) {
        if (sum > 0) {
            sum += num
        } else {
            sum = num
        }
        res = Math.max(res, sum)
    }
    return res
};
```

### 股票问题

#### 买卖股票的最佳时机

```
给定一个数组 prices ，它的第 i 个元素 prices[i] 表示一支给定股票第 i 天的价格。

你只能选择 某一天 买入这只股票，并选择在 未来的某一个不同的日子 卖出该股票。设计一个算法来计算你所能获取的最大利润。

返回你可以从这笔交易中获取的最大利润。如果你不能获取任何利润，返回 0 。

输入：prices = [7,6,4,3,1]
输出：0
解释：在这种情况下, 没有交易完成, 所以最大利润为 0。
```

```js
var maxProfit = function (prices) {
    let max = 0, min = Number.MAX_SAFE_INTEGER
    for (let i = 0; i < prices.length; i++) {
        let price = prices[i]
        min = Math.min(min, price)
        max = Math.max(max, price - min)
    }
    return max
};
```

### 不同路径

```
一个机器人位于一个 m x n 网格的左上角 （起始点在下图中标记为 “Start” ）。

机器人每次只能向下或者向右移动一步。机器人试图达到网格的右下角（在下图中标记为 “Finish” ）。

问总共有多少条不同的路径？

输入：m = 3, n = 2
输出：3
解释：
从左上角开始，总共有 3 条路径可以到达右下角。
1. 向右 -> 向下 -> 向下
2. 向下 -> 向下 -> 向右
3. 向下 -> 向右 -> 向下
```

```js
/**
 * @param {number} m
 * @param {number} n
 * @return {number}
 */
var uniquePaths = function (m, n) {
    if (m <= 0 || n <= 0) return 0

    const dp = new Array(m).fill(0).map(item => new Array(n).fill(1))

    for (let i = 1; i < m; i++) {
        for (let j = 1; j < n; j++) {
            dp[i][j] = dp[i - 1][j] + dp[i][j - 1]
        }
    }
    return dp[m - 1][n - 1]
};
```

### 最小路径和

```
给定一个包含非负整数的 m x n 网格 grid ，请找出一条从左上角到右下角的路径，使得路径上的数字总和为最小。

说明：每次只能向下或者向右移动一步。

输入：grid = [[1,3,1],[1,5,1],[4,2,1]]
输出：7
解释：因为路径 1→3→1→1→1 的总和最小

输入：grid = [[1,2,3],[4,5,6]]
输出：12
```



```js
/**
 * @param {number[][]} grid
 * @return {number}
 */
var minPathSum = function (grid) {
    let row = grid.length, column = grid[0].length
    if (row <= 0 || column <= 0) return 0

    const dp = new Array(row).fill(0).map(item => new Array(column).fill(0))
    //初始化第一步
    dp[0][0] = grid[0][0]

    //填充第一行的数据
    for (let i = 1; i < row; i++) {
        dp[i][0] = dp[i - 1][0] + grid[i][0]
    }

    //填充第一列的数据
    for (let j = 1; j < column; j++) {
        dp[0][j] = dp[0][j - 1] + grid[0][j]
    }

    for (let i = 1; i < row; i++) {
        for (let j = 1; j < column; j++) {
            dp[i][j] = Math.min(dp[i - 1][j], dp[i][j - 1]) + grid[i][j]
        }
    }

    return dp[row - 1][column - 1]
};
```





### 打家劫舍

你是一个专业的小偷，计划偷窃沿街的房屋。每间房内都藏有一定的现金，影响你偷窃的唯一制约因素就是相邻的房屋装有相互连通的防盗系统，如果两间相邻的房屋在同一晚上被小偷闯入，系统会自动报警。

给定一个代表每个房屋存放金额的非负整数数组，计算你 不触动警报装置的情况下 ，一夜之内能够偷窃到的最高金额。

```
输入：[1,2,3,1]
输出：4
解释：偷窃 1 号房屋 (金额 = 1) ，然后偷窃 3 号房屋 (金额 = 3)。
     偷窃到的最高金额 = 1 + 3 = 4 。

输入：[2,7,9,3,1]
输出：12
解释：偷窃 1 号房屋 (金额 = 2), 偷窃 3 号房屋 (金额 = 9)，接着偷窃 5 号房屋 (金额 = 1)。
     偷窃到的最高金额 = 2 + 9 + 1 = 12 。
```

