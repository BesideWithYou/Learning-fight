## 回溯

### 思路

回溯问题其实就是一个决策树的遍历过程

- 路径：已经做出的选择
- 选择列表：你当前可以做的选择
- 结束条件：到达决策树底层，无法再做别的选择

主要可以用来解决全排列的问题，比如n个不重复数字的全排列共有n!个

不管怎么优化都符合回溯框架，时间复杂度也不可能低于O(N!)，因为穷举整棵树是无法避免的。回溯算法就是纯暴力穷举，时间复杂度一般都很高。

### 框架

```javascript
function backtrack(...) {
    for 选择 in 选择列表 {
        做选择
        backtrack(...)
        撤销选择
    }
}
```

### 22括号生成

```
数字 n 代表生成括号的对数，请你设计一个函数，用于能够生成所有可能的并且 有效的 括号组合。
输入：n = 3
输出：["((()))","(()())","(())()","()(())","()()()"]
```

```js
/**
 * @param {number} n
 * @return {string[]}
 */
var generateParenthesis = function (n) {
    if (n === 0) return []

    const res = []
    const track = []
    backtrack(n, n, track, res)
    return res
};

function backtrack(left, right, track, res) {
    if (left < 0 || right < 0) return
    if (left > right) return
    if (left === 0 && right === 0) {
        res.push(track.join(''))
        return res
    }

    track.push('(')
    backtrack(left - 1, right, track, res)
    track.pop()

    track.push(')')
    backtrack(left, right - 1, track, res)
    track.pop()
}
```

