## 回溯

### 思路

回溯问题其实就是一个决策树的遍历过程

- 路径：已经做出的选择
- 选择列表：你当前可以做的选择
- 结束条件：到达决策树底层，无法再做别的选择

主要可以用来解决全排列的问题，比如n个不重复数字的全排列共有n!个

不管怎么优化都符合回溯框架，时间复杂度也不可能低于O(N!)，因为穷举整棵树是无法避免的。回溯算法就是纯暴力穷举，时间复杂度一般都很高。

### 框架

```javascript
const res = []
function backtrack(路径，选择列表) {
    for 选择 of 选择列表 {
        做选择
        backtrack(路径，选择列表)
        撤销选择
    }
}
```

### 22括号生成

```
数字 n 代表生成括号的对数，请你设计一个函数，用于能够生成所有可能的并且 有效的 括号组合。
输入：n = 3
输出：["((()))","(()())","(())()","()(())","()()()"]
```

```js
/**
 * @param {number} n
 * @return {string[]}
 */
var generateParenthesis = function (n) {
    if (n === 0) return []
    const res = []
    const track = []
    backtrack(n, n, track, res)
    return res
};

function backtrack(left, right, track, res) {
    if (left < 0 || right < 0) return
    if (left > right) return
    if (left === 0 && right === 0) {
        res.push(track.join(''))
        return res
    }

    track.push('(')
    backtrack(left - 1, right, track, res)
    track.pop()

    track.push(')')
    backtrack(left, right - 1, track, res)
    track.pop()
}
```

### 46全排列

给定一个 **没有重复** 数字的序列，返回其所有可能的全排列。

```js
/**
 * @param {number[]} nums
 * @return {number[][]}
 */
var permute = function (nums) {
    const res = []
    const track = []
    backtrack(nums, track, res)
    return res
};

function backtrack(nums, track, res) {
    if (track.length === nums.length) {
        res.push(track.slice())
        return
    }

    for (let i = 0; i < nums.length; i++) {
        if (track.includes(nums[i])) {
            continue
        }

        //做选择
        track.push(nums[i])
        //进入下一层决策树
        backtrack(nums, track, res)
        //取消选择
        track.pop()
    }
}
```

